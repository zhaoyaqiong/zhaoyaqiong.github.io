<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[d3+Vue雷达图实现]]></title>
    <url>%2F2020%2F05%2F10%2Fd3-Vue%E9%9B%B7%E8%BE%BE%E5%9B%BE%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[工作上最近需要实现一个雷达图的效果，在网上找了几个实现的过程。结合我自己使用的情况。记录一下我的实现。 参考链接： https://xgfe.github.io/2015/11/24/chenwubai/d3-basicCharts-radar/ Github： https://github.com/zhaoyaqiong/RadarChart 环境准备创建vue项目略 安装d3js1npm install d3 -save 项目结构 雷达图实现分析 如上图所示，雷达图的网轴（蓝色）是多个正多边形构成的，多边形的绘制可以利用圆的半径绘制，我们需要再一开始把绘制的原点移动到画布的中心位置，方便之后的绘制。 导入d3&amp;&amp;添加画布file: RadarChart.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;svg&gt;&lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import * as d3 from &quot;d3&quot;; export default &#123; name: &quot;RadarChart&quot;, data()&#123; return &#123;&#125; &#125;, method: &#123; createRadarChart() &#123; let height = 600, width = 300; let main = d3.select(&apos;.container svg&apos;) .append(&apos;g&apos;) .class(&apos;main&apos;, true) .attr(&apos;transform&apos;, &quot;translate(&quot; + width / 2 + &apos;,&apos; + height / 2 + &apos;)&apos;); &#125; &#125;, mounted() &#123; this.createRadarChart(); &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .container &#123; margin: 30px auto; width: 600px; height: 300px; &#125;&lt;/style&gt; 下面实现的大部分代码在createRadarChart函数中，其他会说明。 绘制雷达图模拟原始数据1234567891011data()&#123; return &#123; chartData: &#123; fieldNames: [&apos;语文&apos;, &apos;数学&apos;, &apos;外语&apos;, &apos;物理&apos;, &apos;化学&apos;, &apos;生物&apos;, &apos;政治&apos;, &apos;历史&apos;, &apos;地理&apos;], values: [ [10, 20, 30, 40, 50, 60, 70, 80, 90], [90, 80, 70, 60, 50, 40, 30, 20, 10] ] &#125; &#125;&#125; 计算网轴坐标并绘制雷达图没有比例尺或者布局提供便利，我们只能自己计算 在data中定义一些常用的数据。 12345678910chartConfig: &#123; radius: 100, // 指标的数量，和fieldNames的长度相同 total: 9, // 网轴的级数，网轴上从小到大有多少个正方形 level: 4, rangeMin: 0, rangeMax: 100, arc: 2 * Math.PI&#125; 计算坐标 1234567891011121314151617181920212223createRadarChart() &#123; ... let onePiece = this.chartConfig.arc / this.chartConfig.total; let polygons = &#123; webs: [], webPoints: [] &#125;; for (let k = this.chartConfig.level; k &gt; 0; k--) &#123; let webs = '', webPoints = []; let r = this.chartConfig.radius / this.chartConfig.level * k; for (let i = 0; i &lt; this.chartConfig.total; i++) &#123; let x = r * Math.sin(i * onePiece), y = r * Math.cos(i * onePiece); webs += x + ',' + y + ' '; webPoints.push(&#123; x: x, y: y &#125;) &#125; polygons.webs.push(webs); polygons.webPoints.push(webPoints); &#125;&#125; 计算网格的坐标就是计算出来了多边形上的坐标点，方便后面添加polygon元素时方便绘制（points属性的赋值）。求点坐标时顺便拼接成字符串。 上面代码中，外层循环代表了一层多边形，内层循环计算了多边形上的点坐标。多边形之间的差异就在于他们的外接圆的半径不同。多边形上的点坐标差异在于它们的角度不同。点的坐标可以由半径乘以角度的正弦和余弦求得。 绘制网轴123456789101112createRadarChart() &#123; ... let webs = main.append('g') .classed('webs', true); webs.selectAll('polygon') .data(polygons.webs) .enter() .append('polygon') .attr('points', function (d) &#123; return d; &#125;)&#125; 添加一个g元素来组合所有代表网轴的元素，选择其中的polygon元素并绑定polygons.webs数组，enter()搭配append()添加新polygon元素，对points进行赋值。 为了显示更加明显，我们添加一些样式 12345678910.webs polygon &#123; fill: white; fill-opacity: 0.5; stroke: gray; stroke-dasharray: 10, 5;&#125;.webs polygon:nth-child(odd) &#123; fill: lightgray;&#125; 效果如下 添加纵轴1234567891011121314151617createRadarChart()&#123; ... let lines = main.append('g') .classed('lines', true); lines.selectAll('line') .data(polygons.webPoints[0]) .enter() .append('line') .attr('x1', 0) .attr('y1', 0) .attr('x2', function (d) &#123; return d.x &#125;) .attr('y2', function (d) &#123; return d.y; &#125;);&#125; 效果图 计算添加雷达图区域雷达图区域是一个不规则的多边形，多边形的点处于纵轴上，并且，点的坐标可以通过点代表的值在纵轴上的占比计算出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566createRadarChart()&#123; ... let areasData = []; let values = this.chartData.values; for (let i = 0; i &lt; values.length; i++) &#123; let value = values[i], area = '', points = []; for (let k = 0; k &lt; this.chartConfig.total; k++) &#123; let r = this.chartConfig.radius * (value[k] - this.chartConfig.rangeMin) / (this.chartConfig.rangeMax - this.chartConfig.rangeMin); let x = r * Math.sin(k * onePiece), y = r * Math.cos(k * onePiece); area += x + ',' + y + ' '; points.push(&#123; x: x, y: y &#125;) &#125; areasData.push(&#123; polygon: area, points: points &#125;) &#125; // 添加g分组包含所有雷达图区域 let areas = main.append('g') .classed('areas', true); // 添加g分组包含雷达图区域下的多边形和圆点 areas.selectAll('g') .data(areasData) .enter() .append('g') .attr('class', function (d, i) &#123; return 'area' + (i + 1); &#125;); for (let i = 0; i &lt; areasData.length; i++) &#123; // 遍历每个雷达图区域 let that = this; let area = areas.select('.area' + (i + 1)), areaData = areasData[i]; area.append('polygon') .attr('points', areaData.polygon) .attr('stroke', function (d, index) &#123; return that.getColor(i); &#125;) .attr('fill', function (d, index) &#123; return that.getColor(i) &#125;); // 绘制雷达图定点 let circles = area.append('g') .classed('circles', true); circles.selectAll('circles') .data(areaData.points) .enter() .append('circle') .attr('cx', function (d) &#123; return d.x &#125;) .attr('cy', function (d) &#123; return d.y &#125;) .attr('r', 3) .attr('stroke', function (d, index) &#123; return that.getColor(i); &#125;); &#125;&#125; 添加样式 12345678.areas polygon&#123; fill-opacity: 0.5; stroke-width: 3;&#125;.areas circle&#123; fill: white; stroke-width: 3;&#125; 效果图 计算文字坐标文字标签在网轴的外围，可以使用计算网轴多边形点的坐标方式计算文字标签的坐标。 123456789101112131415161718192021222324252627282930createRadarChart()&#123; ... // 计算文字坐标 let textPoints = []; let textRadius = this.chartConfig.radius + 20; for (let i = 0; i &lt; this.chartConfig.total; i++) &#123; let x = textRadius * Math.sin(i * onePiece); let y = textRadius * Math.cos(i * onePiece); textPoints.push(&#123; x: x, y: y &#125;) &#125; // 添加到画布 let texts = main.append('g') .classed('texts', true); texts.selectAll('text') .data(textPoints) .enter() .append('text') .attr('x', function (d) &#123; return d.x &#125;) .attr('y', function (d) &#123; return d.y &#125;) .text(function (d, i) &#123; return that.chartData.fieldNames[i]; &#125;)&#125; 效果图 根据数据变化上面的内容基本都是照搬xgfe博客中的内容。 下面的内容是基于我所遇到的需求自己添加的。 在有了雷达图之后，在数据改变的时候，我们想要将已经渲染的雷达图进行变化。 这里需要用到d3的两个函数transition,duration。 我们需要重新计算雷达图的区域并绘制。 因为重复使用，这里我们把计算雷达图区域的函数单独提取出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354calcAreaData()&#123; let areasData = []; let onePiece = this.chartConfig.arc / this.chartConfig.total; let values = this.chartData.values; for (let i = 0; i &lt; values.length; i++) &#123; let value = values[i], area = '', points = []; for (let k = 0; k &lt; this.chartConfig.total; k++) &#123; let r = this.chartConfig.radius * (value[k] - this.chartConfig.rangeMin) / (this.chartConfig.rangeMax - this.chartConfig.rangeMin); let x = r * Math.sin(k * onePiece), y = r * Math.cos(k * onePiece); area += x + ',' + y + ' '; points.push(&#123; x: x, y: y &#125;) &#125; areasData.push(&#123; polygon: area, points: points &#125;) &#125; return areasData;&#125;updateRadarChart()&#123; let index = this.chartData.fieldNames.indexOf(fieldName); if (index === -1)&#123; return null; &#125; this.chartData.values[number][index] = value; let areasData = this.calcAreaData(); let main = d3.select('.container svg .main'); let areas = main.select('.areas'); for (let i = 0; i &lt; areasData.length; i++) &#123; let area = areas.select('.area' + (i + 1)), areaData = areasData[i]; area.selectAll('polygon') .transition() .duration(5000) // 动画持续时间，越小变化时间越短 单位ms .attr('points', areaData.polygon); let circles = area.selectAll('.circles'); circles.selectAll('circle') .data(areaData.points) .transition() .duration(5000) // 动画持续时间，越小变化时间越短 单位ms .attr('cx', function (d) &#123; return d.x &#125;) .attr('cy', function (d) &#123; return d.y &#125;); &#125;&#125; 这里我随便调用了一下updateRadarChart(&#39;地理&#39;,1, 100);看一下效果 基本达成了需要的效果。如果觉得动画时间太长，可以修改duration(time)中的time,单位是ms。 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/svg&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import * as d3 from &quot;d3&quot;; export default &#123; name: &quot;RadarChart&quot;, data() &#123; return &#123; chartData: &#123; fieldNames: [&apos;语文&apos;, &apos;数学&apos;, &apos;外语&apos;, &apos;物理&apos;, &apos;化学&apos;, &apos;生物&apos;, &apos;政治&apos;, &apos;历史&apos;, &apos;地理&apos;], values: [ [10, 20, 30, 40, 50, 60, 70, 80, 90], [90, 80, 70, 60, 50, 40, 30, 20, 10] ] &#125;, chartConfig: &#123; radius: 100, // 指标的数量，和fieldNames的长度相同 total: 9, // 网轴的级数，网轴上从小到大有多少个正方形 level: 4, rangeMin: 0, rangeMax: 100, arc: 2 * Math.PI &#125; &#125; &#125;, methods: &#123; getColor(idx) &#123; let palette = [ &apos;#2ec7c9&apos;, &apos;#b6a2de&apos;, &apos;#5ab1ef&apos;, &apos;#ffb980&apos;, &apos;#d87a80&apos;, &apos;#8d98b3&apos;, &apos;#e5cf0d&apos;, &apos;#97b552&apos;, &apos;#95706d&apos;, &apos;#dc69aa&apos;, &apos;#07a2a4&apos;, &apos;#9a7fd1&apos;, &apos;#588dd5&apos;, &apos;#f5994e&apos;, &apos;#c05050&apos;, &apos;#59678c&apos;, &apos;#c9ab00&apos;, &apos;#7eb00a&apos;, &apos;#6f5553&apos;, &apos;#c14089&apos; ]; return palette[idx % palette.length]; &#125;, createRadarChart() &#123; let that = this; let height = 300, width = 600; let main = d3.select(&apos;.container svg&apos;) .append(&apos;g&apos;) .classed(&apos;main&apos;, true) .attr(&apos;transform&apos;, &quot;translate(&quot; + width / 2 + &apos;,&apos; + height / 2 + &apos;)&apos;); let onePiece = this.chartConfig.arc / this.chartConfig.total; let polygons = &#123; webs: [], webPoints: [] &#125;; for (let k = this.chartConfig.level; k &gt; 0; k--) &#123; let webs = &apos;&apos;, webPoints = []; let r = this.chartConfig.radius / this.chartConfig.level * k; for (let i = 0; i &lt; this.chartConfig.total; i++) &#123; let x = r * Math.sin(i * onePiece), y = r * Math.cos(i * onePiece); webs += x + &apos;,&apos; + y + &apos; &apos;; webPoints.push(&#123; x: x, y: y &#125;) &#125; polygons.webs.push(webs); polygons.webPoints.push(webPoints); &#125; let webs = main.append(&apos;g&apos;) .classed(&apos;webs&apos;, true); webs.selectAll(&apos;polygon&apos;) .data(polygons.webs) .enter() .append(&apos;polygon&apos;) .attr(&apos;points&apos;, function (d) &#123; return d; &#125;); let lines = main.append(&apos;g&apos;) .classed(&apos;lines&apos;, true); lines.selectAll(&apos;line&apos;) .data(polygons.webPoints[0]) .enter() .append(&apos;line&apos;) .attr(&apos;x1&apos;, 0) .attr(&apos;y1&apos;, 0) .attr(&apos;x2&apos;, function (d) &#123; return d.x &#125;) .attr(&apos;y2&apos;, function (d) &#123; return d.y; &#125;); let areasData = this.calcAreaData(); // 添加g分组包含所有雷达图区域 let areas = main.append(&apos;g&apos;) .classed(&apos;areas&apos;, true); // 添加g分组包含雷达图区域下的多边形和圆点 areas.selectAll(&apos;g&apos;) .data(areasData) .enter() .append(&apos;g&apos;) .attr(&apos;class&apos;, function (d, i) &#123; return &apos;area&apos; + (i + 1); &#125;); for (let i = 0; i &lt; areasData.length; i++) &#123; // 遍历每个雷达图区域 let area = areas.select(&apos;.area&apos; + (i + 1)), areaData = areasData[i]; area.append(&apos;polygon&apos;) .attr(&apos;points&apos;, areaData.polygon) .attr(&apos;stroke&apos;, function (d, index) &#123; return that.getColor(i); &#125;) .attr(&apos;fill&apos;, function (d, index) &#123; return that.getColor(i) &#125;); // 绘制雷达图定点 let circles = area.append(&apos;g&apos;) .classed(&apos;circles&apos;, true); circles.selectAll(&apos;circles&apos;) .data(areaData.points) .enter() .append(&apos;circle&apos;) .attr(&apos;cx&apos;, function (d) &#123; return d.x &#125;) .attr(&apos;cy&apos;, function (d) &#123; return d.y &#125;) .attr(&apos;r&apos;, 3) .attr(&apos;stroke&apos;, function (d, index) &#123; return that.getColor(i); &#125;); &#125; // 计算文字坐标 let textPoints = []; let textRadius = this.chartConfig.radius + 20; for (let i = 0; i &lt; this.chartConfig.total; i++) &#123; let x = textRadius * Math.sin(i * onePiece); let y = textRadius * Math.cos(i * onePiece); textPoints.push(&#123; x: x, y: y &#125;) &#125; // 添加到画布 let texts = main.append(&apos;g&apos;) .classed(&apos;texts&apos;, true); texts.selectAll(&apos;text&apos;) .data(textPoints) .enter() .append(&apos;text&apos;) .attr(&apos;x&apos;, function (d) &#123; return d.x &#125;) .attr(&apos;y&apos;, function (d) &#123; return d.y &#125;) .text(function (d, i) &#123; return that.chartData.fieldNames[i]; &#125;) &#125;, calcAreaData()&#123; let areasData = []; let onePiece = this.chartConfig.arc / this.chartConfig.total; let values = this.chartData.values; for (let i = 0; i &lt; values.length; i++) &#123; let value = values[i], area = &apos;&apos;, points = []; for (let k = 0; k &lt; this.chartConfig.total; k++) &#123; let r = this.chartConfig.radius * (value[k] - this.chartConfig.rangeMin) / (this.chartConfig.rangeMax - this.chartConfig.rangeMin); let x = r * Math.sin(k * onePiece), y = r * Math.cos(k * onePiece); area += x + &apos;,&apos; + y + &apos; &apos;; points.push(&#123; x: x, y: y &#125;) &#125; areasData.push(&#123; polygon: area, points: points &#125;) &#125; return areasData; &#125;, updateRadarChart(fieldName, number, value)&#123; let index = this.chartData.fieldNames.indexOf(fieldName); if (index === -1)&#123; return null; &#125; this.chartData.values[number][index] = value; let areasData = this.calcAreaData(); // 添加g分组包含所有雷达图区域 let main = d3.select(&apos;.container svg .main&apos;); let areas = main.select(&apos;.areas&apos;); for (let i = 0; i &lt; areasData.length; i++) &#123; // 遍历每个雷达图区域 let area = areas.select(&apos;.area&apos; + (i + 1)), areaData = areasData[i]; area.selectAll(&apos;polygon&apos;) .transition() .duration(5000) .attr(&apos;points&apos;, areaData.polygon); // 绘制雷达图定点 let circles = area.selectAll(&apos;.circles&apos;); circles.selectAll(&apos;circle&apos;) .data(areaData.points) .transition() .duration(5000) .attr(&apos;cx&apos;, function (d) &#123; return d.x &#125;) .attr(&apos;cy&apos;, function (d) &#123; return d.y &#125;); &#125; &#125; &#125;, mounted() &#123; this.createRadarChart(); this.updateRadarChart(&apos;地理&apos;,1, 100); &#125; &#125;&lt;/script&gt;&lt;style&gt; .container &#123; margin: 30px auto; width: 600px; height: 300px; border: 1px solid #000; &#125; .webs polygon, .lines line &#123; fill: white; fill-opacity: 0.5; stroke: gray; stroke-dasharray: 10, 5; &#125; .areas polygon &#123; fill-opacity: 0.5; stroke-width: 3; &#125; .areas circle &#123; fill: white; stroke-width: 3; &#125; .texts text &#123; font-size: 14px; text-anchor: middle; &#125; .webs polygon:nth-child(odd) &#123; fill: lightgray; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>教程</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Vue创建Quasar前端项目]]></title>
    <url>%2F2019%2F11%2F12%2F%E4%BD%BF%E7%94%A8Vue%E5%88%9B%E5%BB%BAQuasar%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[最近在找vue的组件库，发现了一个名为Quasar的组件库。发现Quasar组件特别丰富，而且文档齐全。准备学习使用一下。 环境准备按照Quasar官网给出的建议，有三种方式可以使用Quasar。 UMD/Standalone (embed into an existing project through CDN, progressive integration) Quasar CLI (the premium developer experience for free, recommended) Vue CLI 3 plugin 关于三种不同创建方法所具体支持的特性可以在 https://quasar.dev/start/pick-quasar-flavour 查看。 我们选择第三种Vue CLI进行项目的创建。 如果要是使用Vue CLI进行使用Quasar。首先确保你全局安装了@vue/cli v3+ 使用下面的命令确保你安装的版本是3.x.x 1vue --version 如果你已经安装了Vue CLI 2.x.x 需要先卸载，然后安装 1234# uninstall vue-cli 2.x.xnpm uninstall -g vue-cli# nstall Vue CLI v3+npm install -g @vue/cli 创建项目创建vue项目首先使用命令来创建一个vue的项目 1vue create my-app 在第一步选择的时候，需要注意必须选Babel，其他根据自己需要选择即可。 接下来按照默认的配置一路回车即可创建出一个vue的项目。 如图显示就说明vue项目创建成功。 不放心的朋友可以执行下面提示的命令，让项目运行一下。 安装Quasar 进入项目目录 如果你还没有进入项目目录。 1cd my-app 安装quasar 1vue add quasar 安装过程中的选项，根据需要选择即可，如果还不太了解的朋友，一路回车选择默认的配置即可。 配置完略等一下就可以创建成功了。 创建成功如下图所示 运行如果没有出什么问题的话，我们就已经将Quasar集成到了Vue的项目中。 我们可以按照安装vue时，提示我们的命令，运行我们的项目 1npm run serve 成功后，即可按照给出的链接 http://localhost:8080/ 访问，查看效果。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿Github Contributions实现]]></title>
    <url>%2F2019%2F09%2F15%2F%E4%BB%BFGitHubContributions%2F</url>
    <content type="text"><![CDATA[前言Github Contributions 是我使用Github的乐趣之一，最近因为遇到了一个类似的需求，所以想着自己模仿着做一个。 通过搜索，网上已经有一些实现，但是因为时间久远的原因，使用的好多第三方库的函数已经被移除。 一步一步将 d3.js Calendar View 转变成 GitHub Contributions By alphahinex How to recreate GitHub’s contribution graph By Vincent Le 本文就将参照两位前辈的博文，进行一些改进。 准备 简单的 HTML 和 CSS （因为只是简单的实现 javascript 以及d3.js。d3是javascript的一个库，全称（Data-Driven Documents）主要用来做数据可视化。 开始创建contributions.html文件，引入d3.js，页面的基本样式。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; body&#123; font-size: 10px; &#125; /* 之后的样式写在这里 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; // 之后我们的逻辑代码都会在这里实现&lt;/script&gt;&lt;/html&gt; 我们之后的css样式会在style里，js代码会在下面的script标签中。 这里，参考Github Contributions的样子。我们定义了Contributions的大小，小的单元格的尺寸，以及默认的填充颜色。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let height = 300, width = 1386, cellSize = 16;let format = d3.timeFormat("%Y-%m-%d");let svg = d3.select("body") .append("svg").attr("width", width).attr("height", height).attr("class", "cv") .append("g").attr("transform", "translate(" + ((width - cellSize * 53) / 2) + "," + (height - cellSize * 7)/2 + ")"); svg.append('text').attr('transform', 'translate(-30,' + cellSize * 1.8 + ')').attr('fill','#767676').text('周一'); svg.append('text').attr('transform', 'translate(-30,' + cellSize * 3.8 + ')').attr('fill','#767676').text('周三'); svg.append('text').attr('transform', 'translate(-30,' + cellSize * 5.8 + ')').attr('fill','#767676').text('周五');let now = new Date();let lastYear = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);let weekOfYear = 53 - d3.timeWeek.count(d3.timeYear(lastYear), lastYear);function transformWeek(d)&#123; let year = d.getFullYear(); let thisYear = now.getFullYear(); let weekCount = d3.timeWeek.count(d3.timeYear(d), d); if (year &lt; thisYear)&#123; weekCount = weekCount - 53 + weekOfYear; &#125;else&#123; weekCount += weekOfYear - 1; &#125; return weekCount&#125;let startYear = lastYear.getFullYear();let startMonth = lastYear.getDate() === 1 ? lastYear.getMonth() : lastYear.getMonth() + 1;for (let i = 0; i &lt; 12; i++) &#123; let s = new Date(startYear, startMonth + i, 1); let w = transformWeek(s) + (s.getDay() &gt; 0 ? 1 : 0); if (w &gt; 52) &#123; break; &#125; let m = s.getMonth() + 1; let l = m &gt; 9 ? m : '0' + m; svg.append('text').attr('transform', 'translate(' + cellSize * w + ', -10)').attr('fill','#767676').text(l);&#125;let rect = svg.selectAll(".day") .data(d3.timeDays(lastYear, now)) .enter().append("rect") .attr("class", "day") .attr("width", cellSize) .attr("height", cellSize) .attr("x", function(d) &#123; return transformWeek(d) * cellSize; &#125;) .attr("y", function(d) &#123; return d.getDay() * cellSize; &#125;) .attr("data-count", 0) .attr("data-date", function(d) &#123; return format(d)&#125;) .attr("fill","#ebedf0") .datum(format); 需要注意的是，在alphahinex前辈的博文中，使用到几个函数，d3.js已经移除。我在自己的实现中也进行了相应的替换。 d3.time.weekOfYear(d) -&gt; d3.timeWeek.count(d3.timeYear(d), d) d3.time.days(time1, time2)-&gt;d3.timeDays(time1, time2) d3.time.format(&quot;%Y-%m-%d&quot;)-&gt;d3.timeFormat(%Y-%m-%d) 上述代码完成后，基本的形状已经大致出来了 但是，单元格都连成一片，我们需要添加样式，将单元格进行一定的区分。 12345678910.day &#123; width: 13px; height: 13px;&#125;.day:hover &#123; stroke-width: 1px; stroke: #f4a460; stroke-linecap: round; vector-effect: non-scaling-stroke;&#125; 现在，样子已经和Github Contributions基本一致了，我们需要对单元格进行染色了。 在我们的js代码下继续添加 1234567891011let data = &#123; '2019-08-31': 1,'2019-09-01': 2,'2019-09-02': 3,'2019-09-03': 4,'2019-09-04': 5, '2019-09-05': 5,'2019-09-06': 6,'2019-09-07': 7,'2019-09-08': 8,'2019-09-09': 9, '2019-09-10': 11,'2019-09-11': 12,'2019-09-12': 13&#125;let colorMap = &#123; 1: '#c6e48b', 2: '#7bc96f', 3: '#239a3b', 4: '#196127'&#125; 模拟出了十几天的数据，同时，我也在github上，对于几种颜色进行了提取。 我们需要定义一个Contributions到颜色的转换 1let transformColor = d3.scaleQuantize().domain([1, 13]).range(d3.range(1,5).map(function(d) &#123; return colorMap[d]; &#125;)); 同时，这里的d3.scaleQuantize 也是d3版本之前d3.scale.quantize()的替换。 在对颜色进行了线性转换后，我们就需要操作单元格，进行填充了。 123456rect.filter(function(d) &#123; return d in data; &#125;) .attr("data-count", function(d) &#123; return data[d]&#125;) .attr("fill", function(d) &#123; return transformColor(data[d])&#125;) .append("title").text(function (d) &#123;return data[d] + ' contributions on ' + d&#125;)rect.filter(function(d) &#123; return !(d in data); &#125;) .append("title").text(function (d) &#123;return 'No contributions on ' + d&#125;) 在填充过后，还对单元格进行了一个鼠标悬浮的文字显示的操作。对于没有数据的单元格，也统一进行了操作。至此，一个仿Github Contributions的小玩意终于也完成了。 忘了图 补一个效果图： 后记d3.js 作为一个强大的数据可视化的库，值得深入学习一下。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>d3</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
